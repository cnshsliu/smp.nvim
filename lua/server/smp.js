"use strict";
const { spawn } = require("child_process");
const marked = require("marked");
const childProcess = require("child_process");
const katex = require("katex");
const path = require("path");
const mime = require("mime-types");
const Hapi = require("@hapi/hapi");
const Wreck = require("@hapi/wreck");
const defaultConfig = require("./config");
const Cheerio = require("cheerio");
const fs = require("fs");
const plantumlEncoder = require("plantuml-encoder");
const { readdir, readFile } = require("fs/promises");

const regex_wiki = /\[\[(.*?)\]\]/g;
const regex_snippet = /^\s*{(.+)}\s*$/;
const regex_comment = /^\s*(lucas|comment|cmt):\s*(.+)$/;
const regex_toc = /\{(:)?(toc|TOC|Toc)\}/;
const regex_a_link = /\[(.*)]\s*\((.+)\)/;
const regex_structure_tag = /\{(:)?(tags)\}/i;
const regex_structure_link = /\{(:)?(links)\}/i;
const regex_structure_backlink = /\{(:)?(backlinks)\}/i;
const regex_table = /^\s*\|(.*\|)+\s*$/;
const regex_4space_codeblock = /^ {4}/;
const regex_tag = / #(.+)( |$)/;
const replacement_tag = '<a href="/hastag?tag=$1" target="_taggedFiles">$1</a>';

class EmpError extends Error {
  details;
  constructor(name, message, details = "") {
    super(message);
    this.name = name;
    this.details = "EmpError: " + details;
  }
}

const copyright = `<center><br/><br/>generated by <a href="https://github.com/cnshsliu/smp.nvim">smp.nvim</a>, created by <a href="https://www.buymeacoffee.com/liukehong">LiuKeHong</a> </center>`;
const navigation_container_lines = [
  '<div id="smp_nav_container">',
  "",
  "## Tags",
  "",
  "{tags}",
  "",
  "## Links",
  "",
  "{links}",
  "",
  "## Backlinks",
  "",
  "{backlinks}",
  "",
  "</div>",
];

let string_stores = {};
let update_key_stores = {};
let chartJs_codes = {};
// let fn_stores = {};

// let serNumber = 0;

const logFile = "smp_server_log.txt";
let current_fn_key = "";
let global_indicator = -1;
const defaultMarkDownCss = "/styles/github-markdown.css";
let smpConfig = {
  css: defaultMarkDownCss,
  tmpdir: "/tmp",
  show_navigation_panel: true,
  show_navigation_content: true,
};
smpConfig = Object.assign({}, smpConfig, defaultConfig);
console.log(smpConfig);

function findKeyByValue(obj, value) {
  const foundKey = Object.keys(obj).find((key) => obj[key] === value);
  return foundKey;
}
function ensureAbsolutePath(inputPath, currentFilePath) {
  if (path.isAbsolute(inputPath)) {
    return inputPath;
  } else {
    const currentDir = path.dirname(currentFilePath); // Get the current file's directory
    const absolutePath = path.join(currentDir, inputPath); // Create an absolute path relative to the current file's directory
    return absolutePath;
  }
}
const smp_links = {};
function generateRandomString(length) {
  let result = "";
  const characters =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}

//katex version: https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css
const getStylesheet = function () {
  const stylesheet = `
  <link rel="stylesheet" href="${smpConfig.css}" type="text/css">
	<link rel="stylesheet" href="/styles/highlight-github.css" type="text/css">
	<link rel="stylesheet" href="/styles/smp.css" type="text/css">
  <link rel="stylesheet" href="/styles/katex.min.css">
  <script src="/diffdom/diffDOM.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

	
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    .markdown-body {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 980px;
      margin: 0 auto;
      padding: 45px;
    }

    @media (max-width: 767px) {
      .markdown-body {
        padding: 15px;
      }
    }
    .ball {
      width: 0;
      height: 0;
      border-right: 1rem solid red;
      margin-left: 0.5rem;
    }

  </style>
`;

  return stylesheet.replace(/\n/g, "");
};

const getTopScript = function () {
  return `
<script>
let current_viewing_line_number = 1;
</script>
`;
};

//insert this script into the html ONCE
const getSmoothScrollScript = function (
  update_key,
  lnr,
  thisline,
  showIndicator = true
) {
  thisline = thisline.replace(/`/g, "\\`");
  return `
  <script type="module">
import * as sxMxPx_x_M1e2r0mxaidJs from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
window.sxMxPx_x_M1e2r0mxaidJs = sxMxPx_x_M1e2r0mxaidJs.default;
let thisTs = 0;
let lastTs = -1;
let use_indicator=undefined;
function removeExistingBalls(){
    const ballElements = document.querySelectorAll(".ball");

    ballElements.forEach((element) => {
      element.classList.remove("ball");
    });
}

function setIndicator(linenr, lineText){
  let thisAnchor=null;
  let foundLineNr = -5;
  for(let i=linenr; i>=0; i--){
      thisAnchor = document.querySelector(\`#lucas_tkbp_\${i}\`);
      if(thisAnchor !==null){
        foundLineNr = i;
        break;
      }else{
      }
  }
  if(thisAnchor !== null){
      removeExistingBalls();
      thisAnchor.classList.add("ball");
  }
  if(foundLineNr !== linenr && lineText.trim()  !==   ""){
    try{window.find(lineText)}catch(err){}
  }
}

function scrollOnly(linenr, lineText){
  linenr = linenr - 3;
  if (linenr < 1) linenr = 0;
  let thisAnchor=null;
  let foundLineNr = -3;
  for(let i=linenr; i>=0; i--){
      thisAnchor = document.querySelector(\`.scrollTo#lucas_tkbp_\${i}\`);
      if(thisAnchor !==null){
        foundLineNr = i;
        break;
      }
  }
  if(thisAnchor !== null){
      try{thisAnchor.scrollIntoView({ behavior: 'smooth', block: 'start' });}catch(err){ }
  }
}

function scrollToLine(linenr, lineText){
  if(use_indicator===undefined?${showIndicator}:use_indicator ) {
  setIndicator(linenr, lineText);
    scrollOnly(linenr, lineText);
  }
}

scrollToLine(${lnr}, \`${thisline}\`);



let fetchFailed = 0;
let intervalId=0;
const dd = new diffDOM.DiffDOM();
function fetchData() {
    let url = "http://127.0.0.1:3040/getupdate/${update_key}/" + thisTs;
    lastTs = thisTs;
    fetch(url)
      .then((response) => {
        return response.json();
      })
      .then((data) => {
        if(data.use_indicator !== undefined)
        {
          if(use_indicator === true && data.use_indicator === false){
              removeExistingBalls();
          }
          use_indicator = data.use_indicator;
        }
        switch(data.code){
          case 'touched_all':
            const oldElement = document.querySelector(".markdown-body");
            const newElement = oldElement.cloneNode(false);

            newElement.innerHTML = data.html;

            const diff = dd.diff(oldElement, newElement);
            dd.apply(oldElement, diff);



            requestAnimationFrame(() => {
              setTimeout(()=>{scrollToLine(data.linenr, data.thisline);}, 200);
            });
            break;
          case 'touched_line':
            scrollToLine(data.linenr, data.thisline);
            break;
          default:
        }
        if(data.ts) {thisTs = data.ts; }
          const mermaidElement = document.querySelector('.mermaid');
          if(mermaidElement){
            window.sxMxPx_x_M1e2r0mxaidJs.initialize({startOnLoad:false});
            window.sxMxPx_x_M1e2r0mxaidJs.run({
              querySelector: '.mermaid',
              suppressErrors: true,
            }).then(()=>{
            })
          }
      })
      .catch((error) => {
        fetchFailed += 1;
        if(fetchFailed > 200){
          try{clearInterval(intervalId);}catch(err){}
        }
      });
}
intervalId = setInterval(fetchData, 500);

const smpanchors = document.querySelectorAll('span.smpanchor');
const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
        current_viewing_line_number = entry.target.id;
        console.log(current_viewing_line_number);
    }
  });
});

smpanchors.forEach(span => {
  observer.observe(span);
});
</script>
  `.replace(/\n/g, "");
};

const getChartJsScript = function () {
  let ids = Object.keys(chartJs_codes);
  let script = "";
  for (let i = 0; i < ids.length; i++) {
    script += `<script>const ${ids[i]} = document.getElementById('${ids[i]}');
new Chart(${ids[i]}, ${chartJs_codes[ids[i]]});</script>`;
  }
  return script;
};

function logToFile(...msgs) {
  const timestamp = new Date().toISOString();
  let message = msgs.join(" ");
  const logMessage = `${timestamp} - ${message}\n`;

  fs.appendFile(logFile, logMessage, (_) => {});
}

// Usage:
const renderer = new marked.Renderer();

// Override the 'codespan' function to handle inline math
renderer.codespan = function (text) {
  if (text.startsWith("\\(") && text.endsWith("\\)")) {
    const latex = text.slice(2, -2);
    return katex.renderToString(latex, { throwOnError: false });
  }
  return `<code>${text}</code>`;
};

const hljs = require("highlight.js");
let hl = function (code, lang) {
  const language = hljs.getLanguage(lang) ? lang : "plaintext";
  return hljs.highlight(code, { language }).value;
};

const imagelizedLang = ["plantuml", "math", "chartjs", "chart"];

function renderMermaid(mermaidCode, lineNr) {
  let svg = "";

  // Render the Mermaid code to an SVG image using a callback function
  mermaid.render("diagram_" + lineNr, mermaidCode, (result) => {
    svg = result;
  });

  // Return the SVG image as a string
  return svg;
}

renderer.code = function (code, codeLang, lineNumber) {
  // return `<pre><code class="language-${codeLang}">${code}</code></pre>`;
  if (codeLang === "math") {
    return katex.renderToString(code, {
      displayMode: true,
      throwOnError: false,
    });
  } else if (codeLang === "plantuml") {
    const imageUrl = generatePlantUmlImageUrl(code);
    return `<img src="${imageUrl}"/>`;
  } else if (codeLang === "mermaid") {
    return `<span class="mermaid">${code}</span>`;
  } else if (codeLang === "chartjs") {
    let chartjs_canvas_id = Object.keys(chartJs_codes).length;
    chartJs_codes[`chartjs_${chartjs_canvas_id}`] = code;
    return `<div style="width: 500px;"><canvas id="chartjs_${chartjs_canvas_id}"></canvas></div>`;
  }
  return `<pre><code class="hljs language-${codeLang}">${hl(
    code,
    codeLang
  )}</code></pre>`;
};

class CustomLexer extends marked.Lexer {
  constructor(options) {
    super(options);
  }

  lex(src) {
    const tokens = [];
    let lineNumber = 1;

    while (src) {
      const nextToken = super.token(src, true);
      if (nextToken) {
        src = src.slice(nextToken.raw.length);

        if (nextToken.type === "code") {
          nextToken.lineNumber = lineNumber;
        }
        lineNumber += (nextToken.raw.match(/\n/g) || []).length;

        tokens.push(nextToken);
      } else {
        src = "";
      }
    }

    return tokens;
  }
}

marked.setOptions({
  renderer: renderer,
  Lexer: CustomLexer,
  highlight: function (code, lang) {
    const hljs = require("highlight.js");
    const language = hljs.getLanguage(lang) ? lang : "plaintext";
    return hljs.highlight(code, { language }).value;
  },
  langPrefix: "hljs language-", // highlight.js css expects a top-level 'hljs' class.
  pedantic: false,
  gfm: true,
  breaks: false,
  sanitize: false,
  smartypants: false,
  xhtml: false,
});

function getKeyByValue(obj, value) {
  for (const key in obj) {
    if (obj[key] === value) {
      return key;
    }
  }
}

function isValidUrl(string) {
  let url;

  try {
    url = new URL(string);
  } catch (_) {
    return false;
  }

  return url.protocol === "http:" || url.protocol === "https:";
}

// function generatePlantUmlImageUrl_experiment(plantUmlSource) {
// 	const uid = generateRandomString(6);
// 	const umlFilePath = path.join(smpConfig.tmpdir, uid + '.uml');
// 	const svgFilePath = path.join(smpConfig.tmpdir, uid + '.svg');
// 	fs.writeFileSync(umlFilePath, plantUmlSource);
// 	childProcess.execFile(
// 		'java',
// 		['-jar', 'plantuml.jar', '-tsvg', '-o', smpConfig.tmpdir, umlFilePath],
// 		(err, stdout, stderr) => {
// 			if (err) {
// 				console.error(err);
// 				return;
// 			}
// 			return 'http://127.0.0.1:3040/plantuml/svg/' + uid;
// 		},
// 	);
// 	return 'http://127.0.0.1:3040/plantuml/svg/' + uid;
// }

function generatePlantUmlImageUrl(plantUmlSource) {
  const encodedPlantUml = plantumlEncoder.encode(plantUmlSource);
  const plantUmlServerUrl = "http://www.plantuml.com/plantuml/svg/";
  return plantUmlServerUrl + encodedPlantUml;
}

const indicator = function (lnr, scroll = true) {
  return `<span class="smpanchor ${scroll ? "scrollto" : ""}" id="lucas_tkbp_${
    lnr + 1
  }">&nbsp;</span>`;
};

function patchAllLines(lines, dir_of_current_md, md_fn, structure) {
  let codeStart = -1;
  let codeEnd = -1;
  let patched = [];
  let pure = [];
  let codeLang = "";
  for (let i = 0; i < lines.length; i++) {
    let x = lines[i];
    pure.push(x);
    let patchedLine = patchLine(
      lines,
      lines[i],
      i,
      dir_of_current_md,
      md_fn,
      structure,
      true
    );
    patched.push(patchedLine);

    //a code block start， at the end of code block,
    //will revert any line patch, and use the original line
    //this is to avoid the line number in code block is changed
    //which will cause the line number in the code block is not correct
    //when the code block is rendered by marked
    //the code block is identified by ``` at the start and end of the block
    //the code block can be identified by the language name, e.g. ```js
    //if the code block is not identified by language name, it is treated as pure text
    if (x.match(/^\s*`/)) {
      if (codeStart < 0) {
        codeStart = i;
        let match = x.match(/```(\w*)/);
        if (match) {
          codeLang = match[1];
        } else {
          codeLang = "";
        }
      } else codeEnd = i;
      if (codeEnd > 0) {
        for (let j = codeStart; j <= codeEnd; j++) {
          patched[j] = pure[j];
        }
        //if its a supported codeLang, we will insert a indicator
        //to indicate the start and end of the code block
        if (imagelizedLang.indexOf(codeLang) >= 0) {
          //for imagelized text, no auto scroll
          //Befote the code start
          //insert a indicator after a new line mark
          patched[codeStart] =
            "&nbsp;" + indicator(codeStart, true) + "\n" + patched[codeStart];

          //For those markdown lines which will be converted
          //into a picture, we insert patch, only used for highlight
          //without scroll to it,
          //Why do we need no-scroll-to location? because if you are
          //editing a imagelizable mardown section which have many lines
          //or when you move cursor within this area
          //the browser will jump to this location
          //make your editing experience unstable.
          patched[codeEnd] += "\n&nbsp;" + indicator(codeStart + 1, false);
        }
        codeStart = -1;
        codeEnd = -1;
        codeLang = "";
      }
    }
  }
  return patched;
}

const getStructureFromContent = function (home, fn, markdown) {
  const links = getLinks(home, markdown);
  const tags = getTags(markdown);
  const backlinks = getBacklinks(home, path.basename(fn, ".md"));

  return { links, tags, backlinks };
};

const find_file = function (directory, file_name) {
  function search_directory(dir_path) {
    const entries = fs.readdirSync(dir_path, { withFileTypes: true });
    for (const entry of entries) {
      const entry_path = path.join(dir_path, entry.name);
      if (entry.isDirectory()) {
        const result = search_directory(entry_path);
        if (result) {
          return result;
        }
      } else if (entry.isFile() && entry.name === file_name) {
        return entry_path;
      }
    }
  }

  return search_directory(directory);
};

const find_title = function (directory, title) {
  return find_file(directory, title + ".md");
};

const getLinks = function (home, markdown) {
  const regex = /\[\[([^\]]+)\]\]/g;

  const links = [];

  for (const match of markdown.matchAll(regex)) {
    const title = match[1];
    const path = find_title(home, title);
    links.push({ title: title, fullpath: path });
  }

  return links;
};

const getTags = function (markdown) {
  const regex = /[\s"'](#\w+)/g;

  let tags = [];

  for (const match of markdown.matchAll(regex)) {
    tags.push(match[1]);
  }
  tags = [...new Set(tags)];
  return tags;
};

function getTodos(directory, withDone = false) {
  const regex_todo = /^\s*- \[ \] (.*)/;

  const todos = {};
  function process_file_todo(file_path, title) {
    const markdown = fs.readFileSync(file_path, "utf8");
    const lines = markdown.split("\n");
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].match(regex_todo)) {
        if (todos[file_path]) {
          todos[file_path].push(lines[i]);
        } else {
          todos[file_path] = [lines[i]];
        }
      }
    }
  }

  function process_directory_todo(dir_path) {
    const entries = fs.readdirSync(dir_path, { withFileTypes: true });
    for (const entry of entries) {
      const entry_path = path.join(dir_path, entry.name);
      if (entry.isDirectory()) {
        process_directory_todo(entry_path);
      } else if (entry.isFile() && entry.name.endsWith(".md")) {
        process_file_todo(entry_path);
      }
    }
  }

  function process_directory_todo(dir_path) {
    let files = get_files_recursive(dir_path);
    files = files.filter((file) => file.endsWith(".md"));
    const sorted_files = sort_files_by_mtime(files);
    for (const file of sorted_files) {
      process_file_todo(file);
    }
  }

  function get_files_recursive(dir_path) {
    let files = [];
    const entries = fs.readdirSync(dir_path, { withFileTypes: true });
    for (const entry of entries) {
      const entry_path = path.join(dir_path, entry.name);
      if (entry.isFile()) {
        files.push(entry_path);
      } else if (entry.isDirectory()) {
        files = files.concat(get_files_recursive(entry_path));
      }
    }
    return files;
  }

  function sort_files_by_mtime(files) {
    return files.sort((a, b) => {
      const a_mtime = fs.statSync(a).mtime.getTime();
      const b_mtime = fs.statSync(b).mtime.getTime();
      return b_mtime - a_mtime;
    });
  }

  process_directory_todo(directory);
  return todos;
}

function getTaggedLines(directory, this_tag) {
  const regex_this_tag = new RegExp(`(${this_tag})`);
  const replacement_this_tag = '<span class="this_tag">$1</span>';

  const taggedLines = {};
  function process_file_taggedLines(file_path, title) {
    const markdown = fs.readFileSync(file_path, "utf8");
    const lines = markdown.split("\n");
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].match(regex_this_tag)) {
        const highlightedLine = lines[i].replace(
          regex_this_tag,
          replacement_this_tag
        );
        if (taggedLines[file_path]) {
          taggedLines[file_path].push({ line: highlightedLine, linenr: i });
        } else {
          taggedLines[file_path] = [{ line: highlightedLine, linenr: i }];
        }
      }
    }
  }

  function process_directory_taggedLines(dir_path) {
    let files = get_files_recursive(dir_path);
    files = files.filter((file) => file.endsWith(".md"));
    const sorted_files = sort_files_by_mtime(files);
    for (const file of sorted_files) {
      process_file_taggedLines(file);
    }
  }

  function get_files_recursive(dir_path) {
    let files = [];
    const entries = fs.readdirSync(dir_path, { withFileTypes: true });
    for (const entry of entries) {
      const entry_path = path.join(dir_path, entry.name);
      if (entry.isFile()) {
        files.push(entry_path);
      } else if (entry.isDirectory()) {
        files = files.concat(get_files_recursive(entry_path));
      }
    }
    return files;
  }

  function sort_files_by_mtime(files) {
    return files.sort((a, b) => {
      const a_mtime = fs.statSync(a).mtime.getTime();
      const b_mtime = fs.statSync(b).mtime.getTime();
      return b_mtime - a_mtime;
    });
  }

  process_directory_taggedLines(directory);
  return taggedLines;
}

function getBacklinks(directory, title) {
  const regex = /\[\[([^\]]+)\]\]/g;

  const backlinks = [];

  function process_file(file_path) {
    const markdown = fs.readFileSync(file_path, "utf8");

    for (const match of markdown.matchAll(regex)) {
      const link = match[1];
      if (link === title) {
        const file = path.basename(file_path);
        const dir = path.dirname(file_path);
        const link_path = path.relative(directory, dir) + "/" + file;
        backlinks.push({
          fullpath: path.join(directory, link_path),
          title: path.basename(file_path, ".md"),
        });
      }
    }
  }

  function process_directory(dir_path) {
    const entries = fs.readdirSync(dir_path, { withFileTypes: true });
    for (const entry of entries) {
      const entry_path = path.join(dir_path, entry.name);
      if (entry.isDirectory()) {
        process_directory(entry_path);
      } else if (entry.isFile() && entry.name.endsWith(".md")) {
        process_file(entry_path);
      }
    }
  }

  process_directory(directory);

  return backlinks;
}

const getNavigationUrl = function (fn, ispreview, section) {
  return (
    "http://127.0.0.1:3040/nav?path=" +
    encodeURIComponent(fn) +
    "&section=" +
    section +
    "&from=" +
    (ispreview ? "preview" : "zettel")
  );
};

const getZettelPath = function (fn) {
  return `http://127.0.0.1:3040/preview?fn_key=${encodeURIComponent(fn)}`;
};
const getTagHref = function (tag, fn) {
  return `http://127.0.0.1:3040/tag?tag=${encodeURIComponent(
    tag
  )}&path=${encodeURIComponent(fn)}`;
};

const getNavigationScript = function () {
  if (smpConfig.show_navigation_panel === false) return "";

  const ret = `
    <script>
      const onPrint = async function () {
        document.getElementById('smp_nav_container')?.classList.add('noshow');
        document.getElementById('smp_nav_panel').classList.add('noshow');
        setTimeout(async () => {
          document.getElementById('smp_nav_container')?.classList.remove('noshow');
          document.getElementById('smp_nav_panel').classList.remove('noshow');
        }, 3000);
      };
      async function print(event){
          onPrint().then(()=>{
            window.print();
          });
      }
      function hideNavigation(event){
          event.preventDefault();
          document.getElementById('smp_nav_container')?.classList.add('noshow');
          document.getElementById('smp_nav_panel').classList.add('noshow');
      }
      function editThis(event, path){
        event.preventDefault(); 
        fetch("http://127.0.0.1:3040/editThis?path=" + encodeURIComponent(path) + "&ln="+ current_viewing_line_number);
      }
    </script>
`;
  return ret;
};

const getNavigationDiv = function (fn, ispreview) {
  if (smpConfig.show_navigation_panel === false) return "";

  const ret = `
    <div id="smp_nav_panel" class="">
		  <div><a href="#" onclick="editThis(event, '${fn}');">Edit</a></div>
      <div><a href="#" onclick="hideNavigation(event)">Hide</a></div>
    </div>
    <style>
      #smp_nav_panel{
        position: fixed; right: 10px;
        bottom: 10px;
        border-radius: 10px;
        background-color: #fff;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        padding: 1rem;
      }
      .noshow{
        display:none;
      }
      .smp_nav_tag, .smp_nav_link, .smp_nav_backlink{
        padding: 3px; border:1px solid; border-radius:5px; margin-right: 5px; margin-bottom: 5px;
      }
  </style>
`;
  return ret;
};
const collectHeaders = function (markdownLines) {
  const headers = [];
  const headerRegex = /^(#{1,6})\s+(.+)$/;
  let inCodes = false;

  markdownLines.forEach((line, index) => {
    if (line.match(/^```/)) {
      inCodes = !inCodes;
    }
    const match = line.match(headerRegex);
    if (match && !inCodes) {
      const level = match[1].length;
      const title = match[2].trim();
      const anchor = title
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, "")
        .replace(/\s+/g, "-");
      headers.push({ level, title, anchor, lineNumber: index + 1 });
    }
  });

  return headers;
};

const generateTOCHTML = function (toc) {
  let html = '<div class="smp-toc"><ul>';
  let previousLevel = 1;

  for (let i = 0; i < toc.length; i++) {
    const currentItem = toc[i];
    const nextItem = toc[i + 1];

    html += `<li><a href="#${currentItem.title}">${currentItem.title}</a></li>`;

    if (nextItem) {
      const levelDifference = nextItem.level - currentItem.level;
      if (levelDifference > 0) {
        html += "<ul>";
      } else if (levelDifference < 0) {
        html += "</ul>".repeat(-levelDifference);
      }
      previousLevel = currentItem.level;
    }
  }

  html += "</ul>".repeat(previousLevel);
  html += "</div>";

  return html;
};

const patchLine = (
  allLines,
  line,
  lnr,
  dir_of_current_md,
  md_fn,
  structure,
  appendIndicator = true
) => {
  //Reference , don't touch
  if (line.match(/^\s*\[.+]:\s*.+$/)) {
    //Refen
    appendIndicator = false;
  } else if (line.match(regex_table)) {
    appendIndicator = false;
  } else if (line.match(regex_4space_codeblock)) {
    appendIndicator = false;
  } else if (line.match(/^\s*$/)) {
    //Patch bank line
    //Blank like, don't touch
    appendIndicator = appendIndicator;
    return "";
  } else if (line.match(regex_toc)) {
    const headers = collectHeaders(allLines);
    line = generateTOCHTML(headers);
  } else if (line.match(regex_tag)) {
    line = line.replace(regex_tag, replacement_tag);
  } else if (line.match(regex_structure_tag)) {
    let tags_html_without_header = '<div class="smp_structure_tags">';
    for (const tag of structure.tags) {
      tags_html_without_header += `<span class="smp_nav_tag"><a href="${getTagHref(
        tag,
        md_fn
      )}">${tag}</a></span>`;
    }
    tags_html_without_header += "</div>";
    line = tags_html_without_header;
  } else if (line.match(regex_structure_link)) {
    let links_html = '<div class="smp_structure_links">';
    for (const link of structure.links) {
      links_html += `<span class="smp_nav_link"><a href="${getZettelPath(
        link.fullpath
      )}">${link.title}</a></span>`;
    }
    links_html += "</div>";
    line = links_html;
  } else if (line.match(regex_structure_backlink)) {
    let backlinks_html = '<div class="smp_structure_backlinks">';
    for (const link of structure.backlinks) {
      backlinks_html += `<span class="smp_nav_backlink"><a href="${getZettelPath(
        link.fullpath
      )}">${link.title}</a></span>`;
    }
    backlinks_html += "</div>";
    line = backlinks_html;
  } else if (line.match(regex_comment)) {
    let m = line.match(regex_comment);
    let comment = m[2].trim();
    line = `<span class="comment">${comment}</span>`;
  } else if (line.match(regex_snippet)) {
    let m = line.match(regex_snippet);
    let snippetName = m[1].trim();
    function parse_snippet_content(snippet, level = 0) {
      //stop parse if level > 9
      if (level > 9) return null;
      if (!(smpConfig && smpConfig.snippets_folder)) {
        logToFile("smpConfig.snippets_folder is not defined");
        return null;
      }
      let fullPath = path.resolve(smpConfig.snippets_folder, snippet + ".md");
      if (fs.existsSync(fullPath)) {
        let content = fs.readFileSync(fullPath, "utf8");
        let lines = content.split("\n");
        let foundChildSnippet = false;
        let retContentLines = [];
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].match(regex_snippet)) {
            foundChildSnippet = true;
            let m = lines[i].match(regex_snippet);
            let childSnippetName = m[1].trim();
            retContentLines.push(
              parse_snippet_content(childSnippetName, level + 1) || lines[i]
            );
          } else {
            retContentLines.push(lines[i]);
          }
        }
        return retContentLines.join("\n") + "\n";
      } else {
        return null;
      }
    }
    if (snippetName) line = parse_snippet_content(snippetName, 0) || line;
  } else if (line.match(/\[\[.+]]/)) {
    //Patch WIKI link
    //Wiki link, a bit more complicated
    //I use this syntax heavily in Telekasten
    let outputString = line.replace(regex_wiki, (match, p1) => {
      let fullPath = path.resolve(
        dir_of_current_md,
        p1.match(/^.+\.(.+)$/) ? p1 : p1 + ".md"
      );
      // const fullPath = path.resolve(p1);
      // const fileName = path.basename(p1);
      const fileExists = fs.existsSync(fullPath);
      if (fileExists) {
        // let myKey = getKeyByValue(fn_stores, fullPath);
        let myKey = encodeURIComponent(fullPath);
        //Give it 'zettel' class, so the display style of zettel can be easily customized later
        return `<span class="zettel"><a href="/preview?fn_key=${myKey}">${p1}</a></span>`;
      } else {
        //also highlight missing zettel file
        return `<span class="notfound">${p1}</span>`;
      }
    });
    // logToFile('convert ' + line + ' to ' + outputString);
    line = outputString;
  } else if (line.match(regex_a_link)) {
    //Patch local MD link
    //如果是 [name](link) 方式
    let outputString = line.replace(regex_a_link, (match, p1, p2) => {
      if (isValidUrl(p2)) {
        //if link is valid url, return normal Markdown link
        return `[${p1}](${p2})`;
      } else if (p2.startsWith("#")) {
        return `[${p1}](${p2})`;
      } else {
        //if a wiki style link to a local file
        //convert it to SMP_LINK handler
        const fullpath = path.resolve(dir_of_current_md, p2);
        return `[${p1}](/preview?fn_key=${encodeURIComponent(fullpath)})`;
      }
    });
    // logToFile(`Replace [${line}] to [${outputString}]`);
    line = outputString;
  }
  return appendIndicator ? `${line}${indicator(lnr)}` : line;
};

function search_tag_in_directory(directory, tags_to_match, tags_to_exclude) {
  const regex = /(?:^|\s+|['"])\s*(#[\p{L}0-9_]+)(?=$|\s|['"])/gu;
  const matches = [];

  const entries = fs.readdirSync(directory, { withFileTypes: true });
  for (const entry of entries) {
    const entry_path = path.join(directory, entry.name);
    if (entry.isDirectory()) {
      matches.push(
        ...search_tag_in_directory(entry_path, tags_to_match, tags_to_exclude)
      );
    } else if (entry.isFile() && entry_path.endsWith(".md")) {
      const file_lines = fs.readFileSync(entry_path, "utf8").split("\n");
      let has_all_tags = true;
      let has_excluded_tags = false;
      let check_true = {};
      let check_false = {};
      for (const line of file_lines) {
        for (const tag of tags_to_match) {
          if (line.match(regex)?.some((t) => t.trim() === tag)) {
            check_true[tag] = true;
          }
        }
        for (const tag of tags_to_exclude) {
          if (line.match(regex)?.some((t) => t.trim() === tag)) {
            check_false[tag] = true;
            break;
          }
        }
      }
      has_all_tags = Object.keys(check_true).length === tags_to_match.length;
      has_excluded_tags = Object.keys(check_false).length > 0;
      if (has_all_tags && !has_excluded_tags) {
        matches.push(entry_path);
      }
    }
  }

  return matches;
}

// Pre-process lines to:
// 1. insert include file content

const preprocessLines = (lines, dir_of_current_md) => {
  for (let i = 0; i < lines.length; i++) {
    let match = lines[i].match(/^\s*(inc|uml):\s+(.+)$/);

    if (match) {
      let umlFilePath = path.resolve(dir_of_current_md, match[2].trim());
      const fileExists = fs.existsSync(umlFilePath);
      if (fileExists) {
        let includedFileContent = fs.readFileSync(umlFilePath, "utf8");
        let includedLines = includedFileContent.split(/\r?\n/);
        if (match[1] === "uml") {
          if (includedLines[0].startsWith("```plantuml") === false) {
            includedLines.unshift("```plantuml");
          }
          if (
            includedLines[includedLines.length - 1].startsWith("```") === false
          ) {
            includedLines.push("```");
          }
        }

        // Replace the matched line with the new lines
        lines.splice(i, 1, ...includedLines);

        // Adjust i to account for the new lines
        i += includedLines.length - 1;
      }
    }
  }
  return lines;
};

const init = async () => {
  const server = Hapi.server({
    port: 3040,
    host: "0.0.0.0",
    routes: {
      cors: {
        origin: ["*"],
        headers: ["Accept", "Content-Type", "Authorization"],
        additionalHeaders: ["cache-control", "x-requested-with"],
      },
      files: {
        relativeTo: path.join(__dirname, "public"),
      },
    },
  });
  await server.register(require("@hapi/inert"));

  server.route({
    method: "GET",
    path: "/{param*}",
    handler: {
      directory: {
        path: ".",
        redirectToSlash: true,
      },
    },
  });

  server.route({
    method: "GET",
    path: "/",
    handler: (_, h) => {
      return "Hello Simple Markdown Preview!";
    },
  });

  server.route({
    method: "POST",
    path: "/indicator",
    handler: (request, _) => {
      let payload = request.payload;
      global_indicator = Number(payload.indicator);
      return "OK";
    },
  });
  server.route({
    method: "POST",
    path: "/togglenav",
    handler: (request, _) => {
      smpConfig.show_navigation_panel = !smpConfig.show_navigation_panel;
      smpConfig.show_navigation_content = !smpConfig.show_navigation_content;
      return "OK";
    },
  });
  server.route({
    method: "POST",
    path: "/urltitle",
    handler: async (request, h) => {
      let payload = request.payload;
      let url = payload.url;
      //get the title of a url
      //https://stackoverflow.com/questions/36572540/nodejs-get-web-page-title
      try {
        const options = {
          timeout: 5000,
        };
        const { payload } = await Wreck.get(url, options);
        const $ = Cheerio.load(payload.toString());
        const title = $("title").text();
        return title;
      } catch (err) {
        if (err.isBoom && err.output.statusCode === 504) {
          return "Timeout 5sec";
        } else {
          console.error(err);
          return h.response("Error fetching title").code(500);
        }
      }
    },
  });
  server.route({
    method: "GET",
    path: "/preview",
    handler: (request, h) => {
      let fn = request.query.fn_key;

      let update_key = findKeyByValue(update_key_stores, fn);
      let md_cache = string_stores[fn];
      if (md_cache) {
        chartJs_codes = {};
        const html = marked.parse(md_cache.string);
        const resp_html =
          "<head>" +
          getStylesheet() +
          getTopScript() +
          '</head>\n<body class="markdown-body">\n' +
          indicator(-1) +
          "<article>\n" +
          html +
          getNavigationScript() +
          getNavigationDiv(fn, true) +
          "</article>" +
          getSmoothScrollScript(
            update_key,
            md_cache.pos[0],
            md_cache.thisline.trim(),
            global_indicator < 0
              ? smpConfig.show_indicator
              : global_indicator === 0
              ? false
              : true
          ) +
          getChartJsScript() +
          copyright +
          "\n</body>";
        return h.response(resp_html);
      } else {
        const fileExists = fs.existsSync(fn);
        if (fileExists) {
          if (!isMarkdownFile(fn)) {
            const fileName = path.basename(fn);
            const encodedFileName = encodeURIComponent(fileName);
            return h
              .file(fn, { confine: false })
              .header("Content-Type", mime.lookup(fileName))
              .header(
                "Content-Disposition",
                `${getDispositionType(
                  fileName
                )}; filename*=UTF-8''${encodedFileName}`
              );
          } else {
            const content = fs.readFileSync(fn, "utf8");
            const structure = getStructureFromContent(
              smpConfig.home,
              fn,
              content
            );
            let lines = content.split(/\r?\n/);
            lines = preprocessLines(lines, path.dirname(fn));

            if (smpConfig.show_navigation_content) {
              lines = lines.concat(navigation_container_lines);
            }
            const patched = patchAllLines(
              lines,
              path.dirname(fn),
              fn,
              structure
            );
            const md_string = patched.join("\n");
            const html = marked.parse(md_string);

            return h.response(
              "<head>" +
                getStylesheet() +
                '</head>\n<body class="markdown-body">\n' +
                "<article>" +
                html +
                getNavigationScript() +
                getNavigationDiv(fn, false) +
                "</article>" +
                copyright +
                "\n</body>"
            );
          }
        } else {
          return h.response(
            "Not found. <br/>You may edit your MD normally, and refresh this page later."
          );
        }
      }
    },
  });

  // This function should use plantuml-encoder to decode the encoded_string
  // and use it to generate teh svg file.
  // server.route({
  // 	method: 'GET',
  // 	path: '/plantuml/{suffix}/{encoded_string}',
  // 	handler: async (request, h) => {
  // 		const suffix = request.params.suffix;
  // 		const uid = request.params.uid;
  // 		console.log(smpConfig.tmpdir, suffix, uid);
  // 		const svgFilePath = path.join(smpConfig.tmpdir, uid + '.' + suffix);
  // 		let exists = false;
  // 		const interval = setInterval(() => {
  // 			exists = fs.existsSync(svgFilePath);
  // 			if (exists) {
  // 				clearInterval(interval);
  // 				const fileName = uid + '.' + suffix;
  // 				const encodedFileName = encodeURIComponent(fileName);
  // 				return h
  // 					.file(svgFilePath, { confine: false })
  // 					.header('Content-Type', mime.lookup(fileName))
  // 					.header(
  // 						'Content-Disposition',
  // 						`${getDispositionType(fileName)}; filename*=UTF-8''${encodedFileName}`,
  // 					);
  // 			}
  // 		}, 1000);
  // 		const timeout = setTimeout(() => {
  // 			clearInterval(interval);
  // 			h.response({ message: 'Diagram generation timed out' }).code(504);
  // 		}, 10000);
  // 	},
  // });

  server.route({
    method: "GET",
    path: "/load",
    handler: (request, h) => {
      let fn = request.query.fn;

      const fileExists = fs.existsSync(fn);
      if (fileExists && isMarkdownFile(fn)) {
        const fileName = path.basename(fn);
        const encodedFileName = encodeURIComponent(fileName);
        return h
          .file(fn, { confine: false })
          .header("Content-Type", mime.lookup(fileName))
          .header(
            "Content-Disposition",
            `${getDispositionType(
              fileName
            )}; filename*=UTF-8''${encodedFileName}`
          );
      }
    },
  });

  server.route({
    method: "GET",
    path: "/remark",
    handler: (request, h) => {
      let fn = request.query.fn;

      const fileExists = fs.existsSync(fn);
      if (fileExists && isMarkdownFile(fn)) {
        let content = fs.readFileSync("./public/remark/remark.html", "utf8");
        let lines = content.split(/\r?\n/);
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].indexOf("sourceUrl:") >= 0) {
            lines[i] = `sourceUrl: '/load?fn=${encodeURIComponent(fn)}'`;
          }
        }
        content = lines.join("\n");
        return h.response(content);
      }
    },
  });

  function replacePath(path, newFolder) {
    let newPath = path.replace(/\/SMP_MD_HOME\//, newFolder);

    return newPath;
  }
  server.route({
    method: "GET",
    path: "/get_fn_key",
    handler: (_, h) => {
      return h.response({ fn_key: encodeURIComponent(current_fn_key) });
    },
  });
  server.route({
    method: "GET",
    path: "/getupdate/{update_key}/{ts}",
    handler: (request, h) => {
      let { update_key, ts } = request.params;
      function getResponse() {
        let use_indicator =
          global_indicator < 0
            ? smpConfig.show_indicator
            : global_indicator === 0
            ? false
            : true;
        let fn_key = update_key_stores[update_key];
        let md_cache = string_stores[fn_key];
        if (md_cache) {
          if (md_cache.ts !== Number(ts)) {
            if (md_cache.touched[0]) {
              const html = marked.parse(md_cache.string);
              return h.response({
                code: "touched_all",
                html: html + getNavigationDiv(fn_key, true),
                linenr: md_cache.pos[0],
                thisline: md_cache.thisline.trim(),
                ts: md_cache.ts,
                use_indicator: use_indicator,
              });
            } else if (md_cache.touched[1]) {
              return h.response({
                code: "touched_line",
                linenr: md_cache.pos[0],
                thisline: md_cache.thisline.trim(),
                ts: md_cache.ts,
                use_indicator: use_indicator,
              });
            } else {
              return h.response({
                code: "touched_none",
                ts: md_cache.ts,
                use_indicator: use_indicator,
              });
            }
          } else {
            return h.response({ code: "notouch" });
          }
        } else {
          return h.response({ code: "nocache" });
        }
      }

      return getResponse();
    },
  });

  server.route({
    method: "GET",
    path: "/todos",
    handler: (_, h) => {
      const todos = getTodos(smpConfig.home);

      const buildTodoHtml = (todos) => {
        let html =
          `<!DOCTYPE html><html><head>` +
          getStylesheet() +
          `<script>
          function editThis(event, path){
            event.preventDefault(); 
            fetch("http://127.0.0.1:3040/editThis?path=" + encodeURIComponent(path) + "&ln=1")
          }
        </script></head>\n<body class="markdown-body">\n`;
        for (const key in todos) {
          if (todos.hasOwnProperty(key)) {
            html += `<h2><a href='#' onclick="editThis(event, '${key}');">${key}</a></h2><ul>`;
            for (let i = 0; i < todos[key].length; i++) {
              html += `<li>${todos[key][i]}</li>`;
            }
            html += "</ul>";
          }
        }
        html += "</body></html>";
        return html;
      };

      return h.response(buildTodoHtml(todos));
    },
  });

  server.route({
    method: "GET",
    path: "/hastag",
    handler: (request, h) => {
      const this_tag = request.query.tag;
      const taggedLines = getTaggedLines(smpConfig.home, this_tag);

      const buildTaggedLinesHtml = (taggedLines) => {
        let html =
          `<!DOCTYPE html><html><head>` +
          getStylesheet() +
          `<script>
          function editThis(event, path, linenr){
            event.preventDefault(); 
            console.log("edit", path, linenr);
            fetch("http://127.0.0.1:3040/editThis?path=" + encodeURIComponent(path) + "&ln=" + linenr)
          }
        </script></head>\n<body class="markdown-body">\n`;
        for (const fileName in taggedLines) {
          if (taggedLines.hasOwnProperty(fileName)) {
            html += `<h2><a href='#' onclick="editThis(event, '${fileName}', 0);">${fileName}</a></h2><ul>`;
            for (let i = 0; i < taggedLines[fileName].length; i++) {
              html += `<li><a href='#' onclick="editThis(event, '${fileName}', ${taggedLines[fileName][i].linenr});">${taggedLines[fileName][i].line}</a></li>`;
            }
            html += "</ul>";
          }
        }
        html += "</body></html>";
        return html;
      };

      return h.response(buildTaggedLinesHtml(taggedLines));
    },
  });

  function isMarkdownFile(filePath) {
    const fileExtension = filePath.split(".").pop();
    return fileExtension === "md";
  }

  function getDispositionType(fileName) {
    // Specify file types that can be displayed inline in the browser
    const inlineFileTypes = [
      "png",
      "jpeg",
      "jpg",
      "pdf",
      "gif",
      "svg",
      "webp",
      "bmp",
    ];

    const contentType = mime.lookup(fileName);
    const fileExtension = mime.extension(contentType);

    // Check if the file extension is in the list of inline file types
    if (fileExtension && inlineFileTypes.includes(fileExtension)) {
      return "inline";
    } else {
      return "attachment";
    }
  }
  server.route({
    method: "GET",
    //this path pattern is generated from Wiki Link: [[myKey]]
    path: "/zettel",
    handler: (request, h) => {
      // Compile
      // let fn = fn_stores[request.query.myKey];
      let fn = request.query.path;
      //fn = replacePath(fn, smpConfig.home);
      const fileExists = fs.existsSync(fn);
      if (fileExists) {
        if (!isMarkdownFile(fn)) {
          const fileName = path.basename(fn);
          const encodedFileName = encodeURIComponent(fileName);
          return h
            .file(fn, { confine: false })
            .header("Content-Type", mime.lookup(fileName))
            .header(
              "Content-Disposition",
              `${getDispositionType(
                fileName
              )}; filename*=UTF-8''${encodedFileName}`
            );
        } else {
          const content = fs.readFileSync(fn, "utf8");
          const structure = getStructureFromContent(
            smpConfig.home,
            fn,
            content
          );
          let lines = content.split(/\r?\n/);
          lines = preprocessLines(lines, path.dirname(fn));

          if (smpConfig.show_navigation_content) {
            lines = lines.concat(navigation_container_lines);
          }
          const patched = patchAllLines(lines, path.dirname(fn), fn, structure);
          const md_string = patched.join("\n");
          const html = marked.parse(md_string);

          return h.response(
            getStylesheet() +
              '<article class="markdown-body">' +
              html +
              getNavigationScript() +
              getNavigationDiv(fn, false) +
              "</article>" +
              copyright
          );
        }
      } else {
        return h.response(
          "Not found. <br/>You may edit your MD normally, and refresh this page later."
        );
      }
    },
  });

  server.route({
    method: "GET",
    //this path pattern is generated from Wiki Link: [[myKey]]
    path: "/tag",
    handler: (request, h) => {
      const tag = request.query.tag;
      const fn = request.query.fn;
      const tagged_files = search_tag_in_directory(smpConfig.home, [tag], []);
      let html = "";
      for (let i = 0; i < tagged_files.length; i++) {
        (html +=
          "<div><a href='/preview?fn_key=" +
          encodeURIComponent(tagged_files[i]) +
          "'>" +
          path.basename(tagged_files[i], ".md")),
          "</a></div>";
      }
      return h.response(
        getStylesheet() +
          '<article class="markdown-body">' +
          `<h2>${tag}</h2>` +
          html +
          "</article>" +
          copyright
      );
    },
  });
  server.route({
    method: "GET",
    //this path pattern is generated from Wiki Link: [[myKey]]
    path: "/editThis",
    handler: (request, h) => {
      // Compile
      // let fn = fn_stores[request.query.myKey];
      let fn = request.query.path;
      let ln = request.query.ln;
      //fn = replacePath(fn, smpConfig.home);
      logToFile("editThis: " + fn + " line: " + ln);
      const fileExists = fs.existsSync(fn);
      function isMarkdownFile(filePath) {
        const fileExtension = filePath.split(".").pop();
        return fileExtension === "md";
      }
      if (fileExists && isMarkdownFile(fn)) {
        console.log(smpConfig.tmpdir);
        fs.writeFile(
          path.join(smpConfig.tmpdir, ".smp.pipe"),
          `editit:${fn}:${ln}:${Date.now()}`,
          (err) => {
            if (err) throw err;
            console.log("The file has been saved!");
          }
        );
        return h.response("Saved");
      }
    },
  });
  server.route({
    method: "GET",
    //this path pattern is within previous output, which is a generate by marked from [name](./assets/....)
    path: "/zettel/{path}/{any*}",
    handler: (request, h) => {
      let fn = path.join(
        smpConfig.home,
        request.params.path,
        request.params.any
      );
      return h.file(fn, { confine: false });
    },
  });
  server.route({
    method: "POST",
    path: "/config",
    handler: (request, h) => {
      let payload = request.payload;
      if (payload.cssfile) {
        if (fs.existsSync(payload.cssfile)) {
          smpConfig.css = `http://127.0.0.1:3040/SMP_LINK/${Buffer.from(
            payload.cssfile
          ).toString("base64")}`;
        } else {
          smpConfig.css = defaultMarkDownCss;
        }
      }
      const keys = ["snippets_folder", "home", "show_indicator", "tmpdir"];
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        smpConfig[key] = payload[key];
      }
      if (smpConfig.home && smpConfig.home.endsWith("/") === false) {
        smpConfig.home += "/";
      }
      logToFile("config updated: " + JSON.stringify(smpConfig, null, 2));
      return h.response("config updated");
    },
  });
  server.route({
    method: "POST",
    path: "/update",
    handler: (request, h) => {
      let payload = request.payload;
      let fn = payload.fn;
      let lines = payload.lines;
      if (smpConfig.show_navigation_content) {
        lines = lines.concat(navigation_container_lines);
      }
      console.log("/update", fn);
      let fn_key = payload.fn_key;
      if (!fn_key || !fn) {
        payload.lines.splice(1, payload.lines.length - 1, "...");
        logToFile(
          "fn_key is undefined, bypass update " + JSON.stringify(payload)
        );
        return h.response("fn_key is undefined, bypass update");
      }
      fn_key = decodeURIComponent(fn_key);
      let update_key = findKeyByValue(update_key_stores, fn_key);
      if (!update_key) {
        update_key_stores[generateRandomString(16)] = fn_key;
      }
      if (lines.length > 0 && lines[0] !== "NO_CHANGE") {
        //update content
        const structure = getStructureFromContent(
          smpConfig.home,
          fn_key,
          lines.join("\n")
        );
        lines = preprocessLines(lines, path.dirname(fn));
        let patched = patchAllLines(lines, path.dirname(fn), fn, structure);
        let md_string = patched.join("\n");
        string_stores[fn_key] = {
          string: md_string,
          pos: payload.pos,
          fn: payload.fn,
          fn_key: payload.fn_key,
          thisline: payload.thisline,
          touched: [true, true], //touch content and linenr
          ts: new Date().getTime(),
        };
        current_fn_key = fn_key;
        logToFile(
          "Update content:\t" +
            current_fn_key +
            " , pos to :" +
            JSON.stringify(payload.pos)
        );
        //TODO: must update without defer
      } else {
        current_fn_key = fn_key;
        logToFile(
          "Update position:\t" +
            current_fn_key +
            " , pos to: " +
            JSON.stringify(payload.pos)
        );
        let store = string_stores[fn_key];
        if (store) {
          string_stores[fn_key] = {
            string: store.string,
            pos: payload.pos,
            fn: payload.fn,
            fn_key: fn_key,
            thisline: payload.thisline,
            touched: [false, true], //touch linenr only
            ts: new Date().getTime(),
          };
        }
      }
      let ret = `Bufnr: ${payload.bufnr}, Pos: ${payload.pos}, Stores: ${
        Object.keys(string_stores).length
      } `;
      const response = h.response(ret);
      response.header("Connection", "keep-alive");
      return response;
    },
  });
  server.route({
    method: "POST",
    path: "/stop",
    handler: (request, h) => {
      logToFile("Receive stop request, stop now!!!");
      setTimeout(() => {
        process.exit(1);
      }, 1000);
      return "Stopped";
    },
  });
  server.route({
    method: "POST",
    path: "/mind/check/telekasten",
    handler: async (request, h) => {
      const PLD = request.payload;
      const fullPath = path.join("/Users/lucas/mdnotes", `${PLD.title}.md`);
      const fileExists = fs.existsSync(fullPath);

      if (fileExists) {
        const content = await readFile(fullPath, "utf8");
        return h
          .response({ title: PLD.title, content })
          .header("Access-Control-Allow-Origin", "*");
      } else {
        return h
          .response({ error: "NOT_FOUND", title: PLD.title })
          .header("Access-Control-Allow-Origin", "*");
      }
    },
  });
  function writeFile(filePath, content) {
    fs.writeFileSync(filePath, content, "utf8");
  }

  server.route({
    method: "POST",
    path: "/mind/save/telekasten",
    handler: async (request, h) => {
      const PLD = request.payload;
      const fullPath = path.join("/Users/lucas/mdnotes", `${PLD.title}.md`);
      writeFile(fullPath, PLD.content);
      return h.response("DONE");
    },
  });

  const path_to_title = (mdnotesPath, path) => {
    let trimmed = path.replace(mdnotesPath, "");
    if (trimmed[0] === "/") trimmed = trimmed.substring(1);
    let replaced = trimmed.replace("/", "_");
    let final = replaced.replace(".md", "");
    return final;
  };

  server.route({
    method: ["GET"],
    path: "/list/filepath",
    handler: async (request, h) => {
      const readFilesRecursive = async (directory, ret) => {
        const files = await readdir(directory, { withFileTypes: true });

        for (const file of files) {
          if (file.isDirectory()) {
            await readFilesRecursive(path.join(directory, file.name), ret);
          } else if (file.isFile() && file.name.endsWith(".md")) {
            const pureFileName = path.basename(file.name, ".md");
            let filepath = path.join(directory, file.name);
            ret.push({
              title: filepath
                .replace(smpConfig.home, "")
                .replace(/^\//, "")
                .replace(/.md$/, ""),
            });
          }
        }
      };

      let ret = [];
      try {
        await readFilesRecursive(smpConfig.home, ret);
      } catch (err) {
        console.log(err);
      }
      return h.response(ret).header("Access-Control-Allow-Origin", "*");
    },
  });

  server.route({
    method: "POST",
    path: "/get/content",
    handler: async (request, h) => {
      const PLD = request.payload;
      const content = await readFile(
        path.join(smpConfig.home, PLD.title + ".md"),
        "utf8"
      );
      const ret = { path: PLD.filePath, content: content };
      return h.response(ret).header("Access-Control-Allow-Origin", "*");
    },
  });

  server.route({
    method: "POST",
    path: "/mind/localedit",
    handler: async (request, h) => {
      const PLD = request.payload;
      const nvimPath = "/opt/homebrew/bin/neovide";
      const filePath = path.join(smpConfig.home, PLD.title + ".md");

      const nvim = spawn(nvimPath, [filePath], {
        detached: true,
        stdio: "ignore",
      });

      nvim.unref();

      return h.response("okay").header("Access-Control-Allow-Origin", "*");
    },
  });

  await server.start();
  logToFile("Server running on " + server.info.uri);
  console.log("Server running on " + server.info.uri);
};

process.on("unhandledRejection", (err) => {
  console.log(err);
  process.exit(1);
});

init();
